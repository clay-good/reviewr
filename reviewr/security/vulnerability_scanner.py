"""
Vulnerability scanner using OSV (Open Source Vulnerabilities) database.

Scans dependencies for known vulnerabilities and provides remediation guidance.
"""

import json
import re
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any, Set
from pathlib import Path
from enum import Enum

try:
    import requests
except ImportError:
    requests = None


class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    UNKNOWN = "unknown"


@dataclass
class Vulnerability:
    """A security vulnerability in a dependency."""
    id: str  # CVE-XXXX-XXXX or GHSA-XXXX-XXXX-XXXX
    package: str
    version: str
    severity: VulnerabilitySeverity
    summary: str
    details: str
    cwe_ids: List[str] = field(default_factory=list)
    cvss_score: Optional[float] = None
    fixed_versions: List[str] = field(default_factory=list)
    references: List[str] = field(default_factory=list)
    published: Optional[str] = None
    modified: Optional[str] = None
    
    @property
    def is_critical(self) -> bool:
        """Check if vulnerability is critical."""
        return self.severity == VulnerabilitySeverity.CRITICAL
    
    @property
    def is_high(self) -> bool:
        """Check if vulnerability is high severity."""
        return self.severity == VulnerabilitySeverity.HIGH
    
    @property
    def has_fix(self) -> bool:
        """Check if a fix is available."""
        return len(self.fixed_versions) > 0
    
    def get_remediation(self) -> str:
        """Get remediation guidance."""
        if self.has_fix:
            versions = ", ".join(self.fixed_versions[:3])
            return f"Update {self.package} to version {versions} or later"
        return f"No fix available yet for {self.package}. Monitor {self.id} for updates."


class VulnerabilityScanner:
    """Scanner for dependency vulnerabilities using OSV database."""
    
    OSV_API_URL = "https://api.osv.dev/v1/query"
    OSV_BATCH_URL = "https://api.osv.dev/v1/querybatch"
    
    def __init__(self, cache_dir: Optional[Path] = None):
        """
        Initialize vulnerability scanner.
        
        Args:
            cache_dir: Directory for caching vulnerability data
        """
        if requests is None:
            raise ImportError(
                "requests library is required for vulnerability scanning. "
                "Install with: pip install requests"
            )
        
        self.cache_dir = cache_dir or Path.home() / ".reviewr" / "vuln_cache"
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        self._cache: Dict[str, List[Vulnerability]] = {}
    
    def scan_requirements_txt(self, file_path: Path) -> List[Vulnerability]:
        """
        Scan a requirements.txt file for vulnerabilities.
        
        Args:
            file_path: Path to requirements.txt
            
        Returns:
            List of vulnerabilities found
        """
        dependencies = self._parse_requirements_txt(file_path)
        return self.scan_dependencies(dependencies, ecosystem="PyPI")
    
    def scan_package_json(self, file_path: Path) -> List[Vulnerability]:
        """
        Scan a package.json file for vulnerabilities.
        
        Args:
            file_path: Path to package.json
            
        Returns:
            List of vulnerabilities found
        """
        dependencies = self._parse_package_json(file_path)
        return self.scan_dependencies(dependencies, ecosystem="npm")
    
    def scan_go_mod(self, file_path: Path) -> List[Vulnerability]:
        """
        Scan a go.mod file for vulnerabilities.
        
        Args:
            file_path: Path to go.mod
            
        Returns:
            List of vulnerabilities found
        """
        dependencies = self._parse_go_mod(file_path)
        return self.scan_dependencies(dependencies, ecosystem="Go")
    
    def scan_cargo_toml(self, file_path: Path) -> List[Vulnerability]:
        """
        Scan a Cargo.toml file for vulnerabilities.
        
        Args:
            file_path: Path to Cargo.toml
            
        Returns:
            List of vulnerabilities found
        """
        dependencies = self._parse_cargo_toml(file_path)
        return self.scan_dependencies(dependencies, ecosystem="crates.io")
    
    def scan_dependencies(
        self,
        dependencies: Dict[str, str],
        ecosystem: str
    ) -> List[Vulnerability]:
        """
        Scan dependencies for vulnerabilities.
        
        Args:
            dependencies: Dict of package name to version
            ecosystem: Package ecosystem (PyPI, npm, Go, crates.io, etc.)
            
        Returns:
            List of vulnerabilities found
        """
        vulnerabilities = []
        
        # Batch query for better performance
        queries = []
        for package, version in dependencies.items():
            cache_key = f"{ecosystem}:{package}:{version}"
            
            # Check cache first
            if cache_key in self._cache:
                vulnerabilities.extend(self._cache[cache_key])
                continue
            
            queries.append({
                "package": {"name": package, "ecosystem": ecosystem},
                "version": version
            })
        
        if not queries:
            return vulnerabilities
        
        # Query OSV API
        try:
            response = requests.post(
                self.OSV_BATCH_URL,
                json={"queries": queries},
                timeout=30
            )
            response.raise_for_status()
            results = response.json()
            
            # Process results
            for i, result in enumerate(results.get("results", [])):
                query = queries[i]
                package = query["package"]["name"]
                version = query["version"]
                ecosystem = query["package"]["ecosystem"]
                
                vulns = self._process_osv_response(result, package, version)
                
                # Cache results
                cache_key = f"{ecosystem}:{package}:{version}"
                self._cache[cache_key] = vulns
                
                vulnerabilities.extend(vulns)
        
        except requests.RequestException as e:
            print(f"Warning: Failed to query OSV API: {e}")
        
        return vulnerabilities
    
    def _process_osv_response(
        self,
        response: Dict[str, Any],
        package: str,
        version: str
    ) -> List[Vulnerability]:
        """Process OSV API response into Vulnerability objects."""
        vulnerabilities = []
        
        for vuln_data in response.get("vulns", []):
            # Extract severity
            severity = self._extract_severity(vuln_data)
            
            # Extract CWE IDs
            cwe_ids = []
            for ref in vuln_data.get("references", []):
                if ref.get("type") == "WEB" and "CWE-" in ref.get("url", ""):
                    match = re.search(r"CWE-(\d+)", ref["url"])
                    if match:
                        cwe_ids.append(f"CWE-{match.group(1)}")
            
            # Extract fixed versions
            fixed_versions = []
            for affected in vuln_data.get("affected", []):
                for range_info in affected.get("ranges", []):
                    for event in range_info.get("events", []):
                        if "fixed" in event:
                            fixed_versions.append(event["fixed"])
            
            # Extract CVSS score
            cvss_score = None
            for severity_info in vuln_data.get("severity", []):
                if severity_info.get("type") == "CVSS_V3":
                    score_str = severity_info.get("score", "")
                    match = re.search(r"(\d+\.\d+)", score_str)
                    if match:
                        cvss_score = float(match.group(1))
            
            # Extract references
            references = [
                ref.get("url", "")
                for ref in vuln_data.get("references", [])
                if ref.get("url")
            ]
            
            vulnerability = Vulnerability(
                id=vuln_data.get("id", "UNKNOWN"),
                package=package,
                version=version,
                severity=severity,
                summary=vuln_data.get("summary", "No summary available"),
                details=vuln_data.get("details", ""),
                cwe_ids=cwe_ids,
                cvss_score=cvss_score,
                fixed_versions=fixed_versions,
                references=references,
                published=vuln_data.get("published"),
                modified=vuln_data.get("modified")
            )
            
            vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _extract_severity(self, vuln_data: Dict[str, Any]) -> VulnerabilitySeverity:
        """Extract severity from vulnerability data."""
        # Try database_specific severity
        db_specific = vuln_data.get("database_specific", {})
        severity_str = db_specific.get("severity", "").lower()
        
        if severity_str:
            try:
                return VulnerabilitySeverity(severity_str)
            except ValueError:
                pass
        
        # Try CVSS score
        for severity_info in vuln_data.get("severity", []):
            if severity_info.get("type") == "CVSS_V3":
                score_str = severity_info.get("score", "")
                match = re.search(r"(\d+\.\d+)", score_str)
                if match:
                    score = float(match.group(1))
                    if score >= 9.0:
                        return VulnerabilitySeverity.CRITICAL
                    elif score >= 7.0:
                        return VulnerabilitySeverity.HIGH
                    elif score >= 4.0:
                        return VulnerabilitySeverity.MEDIUM
                    else:
                        return VulnerabilitySeverity.LOW
        
        return VulnerabilitySeverity.UNKNOWN
    
    def _parse_requirements_txt(self, file_path: Path) -> Dict[str, str]:
        """Parse requirements.txt file."""
        dependencies = {}
        
        try:
            with open(file_path, 'r') as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith('#'):
                        continue
                    
                    # Parse package==version or package>=version
                    match = re.match(r'^([a-zA-Z0-9_-]+)\s*([=><]+)\s*([0-9.]+)', line)
                    if match:
                        package, operator, version = match.groups()
                        if operator in ('==', '>=', '>'):
                            dependencies[package] = version
        
        except Exception as e:
            print(f"Warning: Failed to parse {file_path}: {e}")
        
        return dependencies
    
    def _parse_package_json(self, file_path: Path) -> Dict[str, str]:
        """Parse package.json file."""
        dependencies = {}
        
        try:
            with open(file_path, 'r') as f:
                data = json.load(f)
                
                # Combine dependencies and devDependencies
                for dep_type in ['dependencies', 'devDependencies']:
                    for package, version in data.get(dep_type, {}).items():
                        # Remove ^ and ~ prefixes
                        clean_version = version.lstrip('^~')
                        dependencies[package] = clean_version
        
        except Exception as e:
            print(f"Warning: Failed to parse {file_path}: {e}")
        
        return dependencies
    
    def _parse_go_mod(self, file_path: Path) -> Dict[str, str]:
        """Parse go.mod file."""
        dependencies = {}
        
        try:
            with open(file_path, 'r') as f:
                in_require = False
                for line in f:
                    line = line.strip()
                    
                    if line.startswith('require ('):
                        in_require = True
                        continue
                    elif line == ')':
                        in_require = False
                        continue
                    
                    if in_require or line.startswith('require '):
                        match = re.match(r'require\s+([^\s]+)\s+v([0-9.]+)', line)
                        if not match:
                            match = re.match(r'([^\s]+)\s+v([0-9.]+)', line)
                        
                        if match:
                            package, version = match.groups()
                            dependencies[package] = version
        
        except Exception as e:
            print(f"Warning: Failed to parse {file_path}: {e}")
        
        return dependencies
    
    def _parse_cargo_toml(self, file_path: Path) -> Dict[str, str]:
        """Parse Cargo.toml file."""
        dependencies = {}
        
        try:
            with open(file_path, 'r') as f:
                in_dependencies = False
                for line in f:
                    line = line.strip()
                    
                    if line == '[dependencies]':
                        in_dependencies = True
                        continue
                    elif line.startswith('[') and in_dependencies:
                        in_dependencies = False
                        continue
                    
                    if in_dependencies:
                        # Parse package = "version" or package = { version = "version" }
                        match = re.match(r'([a-zA-Z0-9_-]+)\s*=\s*"([0-9.]+)"', line)
                        if match:
                            package, version = match.groups()
                            dependencies[package] = version
                        else:
                            match = re.match(r'([a-zA-Z0-9_-]+)\s*=\s*\{.*version\s*=\s*"([0-9.]+)"', line)
                            if match:
                                package, version = match.groups()
                                dependencies[package] = version
        
        except Exception as e:
            print(f"Warning: Failed to parse {file_path}: {e}")
        
        return dependencies

